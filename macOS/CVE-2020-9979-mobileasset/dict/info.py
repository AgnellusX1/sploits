#!/usr/bin/env python3

import os
import sys
import zipfile
import hashlib
import binascii
import plistlib

import urllib.request


def hexdump(seq):
    return ''.join(['\\x%02x' % c for c in seq])


def original():
    url = ''.join([
        'https://mesu.apple.com/assets/macos/',
        'com_apple_MobileAsset_DictionaryServices_dictionaryOSX/',
        'com_apple_MobileAsset_DictionaryServices_dictionaryOSX.xml'
    ])

    with urllib.request.urlopen(url) as fp:
        content = fp.read()

    tree = plistlib.loads(content)
    node = next(asset for asset in tree['Assets'] \
        if asset['DictionaryIdentifier'] == 'com.apple.dictionary.AppleDictionary')

    return {
        'ORIGINAL_DICTIONARY_URL': node['__BaseURL'] + node['__RelativePath'],
        'ORIGINAL_SHA1_DIGEST_BYTES': hexdump(node['_Measurement']),
        'ORIGINAL_DOWNLOAD_SIZE': node['_DownloadSize'],
        'ORIGINAL_UNARCHIVED_SIZE': node['_UnarchivedSize'],
    }


def fake(archive):
    uncompressed = 0
    with zipfile.ZipFile(archive) as zf:
        uncompressed = sum([info.file_size for info in zf.infolist()])

    BUF_SIZE = 65536
    sha1 = hashlib.sha1()
    with open(archive, 'rb') as f:
        while True:
            data = f.read(BUF_SIZE)
            if not data:
                break

            sha1.update(data)

    size = os.path.getsize(archive)
    digest = hexdump(sha1.digest())

    return {
        'DICTIONARY_URL': os.environ.get('DICTIONARY_URL', 'http://127.0.0.1:1234/assets/dict.zip'),
        'DOWNLOAD_SIZE': size,
        'UNARCHIVED_SIZE': uncompressed,
        'SHA1_DIGEST_BYTES': digest
    }


def main(archive, template, header):
    mapping = {}
    mapping.update(fake(archive))
    mapping.update(original())

    rendered = []
    for key, val in mapping.items():
        escaped = f'''"{val}"''' if type(val) is str else val
        line = f'''#define {key} {escaped}'''
        rendered.append(line)

    with open(template, 'r') as fp:
        source = fp.read()

    output = []
    inside = False
    for line in source.splitlines():
        if '// generated stub //' in line:
            inside = True

        if not inside:
            output.append(line)

        if inside and '// generated stub ends //' in line:
            output.append('\n'.join(rendered))
            inside = False

    code = '\n'.join(output)
    print('header preview: ')
    print(code)

    with open(header, 'w') as fp:
        fp.write(code)


if __name__ == '__main__':
    if len(sys.argv) != 4:
        print('usage: info.py zip template header')
        sys.exit()

    main(*sys.argv[1:])
