//
//  WebCoreApi.c
//  sbesc
//
//  Created by codecolorist on 2018/12/3.
//  Copyright Â© 2018 AntFinancial. All rights reserved.
//

#include "WebCoreApi.h"
#include <assert.h>
#include <stdlib.h>

WebKitApi api = {0};

void *FindSymbol(const struct mach_header *img, const char *symbol) {
  if ((img == NULL) || (symbol == NULL))
    return NULL;

    // only 64bit supported
#if defined(__LP64__)

  if (img->magic != MH_MAGIC_64)
    return NULL;

  struct mach_header_64 *image = (struct mach_header_64 *)img;

  struct segment_command_64 *seg_linkedit = NULL;
  struct segment_command_64 *seg_text = NULL;
  struct symtab_command *symtab = NULL;
  unsigned int index;

  struct load_command *cmd = (struct load_command *)(image + 1);

  for (index = 0; index < image->ncmds; index += 1, cmd = (struct load_command *)((char *)cmd + cmd->cmdsize)) {
    switch (cmd->cmd) {
    case LC_SEGMENT_64: {
      struct segment_command_64 *segcmd = (struct segment_command_64 *)cmd;
      if (!strcmp(segcmd->segname, SEG_TEXT))
        seg_text = segcmd;
      else if (!strcmp(segcmd->segname, SEG_LINKEDIT))
        seg_linkedit = segcmd;
      break;
    }

    case LC_SYMTAB:
      symtab = (struct symtab_command *)cmd;
      break;

    default:
      break;
    }
  }

  if ((seg_text == NULL) || (seg_linkedit == NULL) || (symtab == NULL))
    return NULL;

  unsigned long vm_slide = (unsigned long)image - (unsigned long)seg_text->vmaddr;
  unsigned long file_slide =
      ((unsigned long)seg_linkedit->vmaddr - (unsigned long)seg_text->vmaddr) - seg_linkedit->fileoff;
  struct nlist_64 *symbase = (struct nlist_64 *)((unsigned long)image + (symtab->symoff + file_slide));
  char *strings = (char *)((unsigned long)image + (symtab->stroff + file_slide));
  struct nlist_64 *sym;

  for (index = 0, sym = symbase; index < symtab->nsyms; index += 1, sym += 1) {
    if (sym->n_un.n_strx != 0 && !strcmp(symbol, strings + sym->n_un.n_strx)) {
      unsigned long address = vm_slide + sym->n_value;
      if (sym->n_desc & N_ARM_THUMB_DEF)
        return (void *)(address | 1);
      else
        return (void *)(address);
    }
  }
#else
#error only supports x86-64
#endif

  return NULL;
}

WebKitApi *getWebKitApi() {
  if (api.header)
    return &api;

#define RESOLVE_API(N, SYMBOL)                                                                                         \
  api.N = FindSymbol(api.header, SYMBOL);                                                                              \
  assert(api.N)

  for (uint32_t i = 0; i < _dyld_image_count(); i++) {
    const char *name = _dyld_get_image_name(i);
    const char *base = strrchr(name, '/');
    if (base && strcmp(base + 1, "WebKit") == 0) {
      api.header = _dyld_get_image_header(i);

      /*
       WebKit::WebProcess::singleton()
       WebKit::WebProcess::webPage(unsigned long long) const
       WebKit::WebProcess::focusedWebPage() const
       WebKit::WebPage::performDictionaryLookupOfCurrentSelection()
       */

      RESOLVE_API(getWebProcess, "__ZN6WebKit10WebProcess9singletonEv");
      RESOLVE_API(getFocusedPage, "__ZNK6WebKit10WebProcess14focusedWebPageEv");
      RESOLVE_API(performLookup, "__ZN6WebKit7WebPage41performDictionaryLookupOfCurrentSelectionEv");

      return &api;
    }
  }

  // should not reach
  abort();
}
